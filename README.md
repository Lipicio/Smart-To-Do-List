# Smart To-Do List

Aplica√ß√£o **Full-Stack** moderna que permite gerenciar tarefas de forma inteligente, integrando **NestJS** no backend, **Next.js** no frontend e **SQLite** como banco de dados.  
O projeto √© dockerizado para facilitar o setup e execu√ß√£o.

---

## üèó Estrutura do Projeto

smart-todo/\
‚îú‚îÄ backend/ # Backend NestJS + SQLite + Dockerfile\
‚îÇ ‚îú‚îÄ src/\
‚îÇ ‚îú‚îÄ package.json\
‚îÇ ‚îú‚îÄ Dockerfile\
‚îÇ ‚îî‚îÄ tsconfig.json\
‚îú‚îÄ frontend/ # Frontend Next.js + Tailwind + React Compiler\
‚îÇ ‚îú‚îÄ app/\
‚îÇ ‚îú‚îÄ package.json\
‚îÇ ‚îú‚îÄ Dockerfile\
‚îÇ ‚îú‚îÄ tailwind.config.js\
‚îÇ ‚îî‚îÄ tsconfig.json\
‚îú‚îÄ docker-compose.yml # Orquestra√ß√£o dos containers\
‚îú‚îÄ .gitignore\
‚îî‚îÄ README.md\


---

## üöÄ Pr√©-requisitos

- Docker  
- Docker Compose  
- Git  

> N√£o √© necess√°rio instalar Node.js ou SQLite localmente ‚Äî tudo roda dentro dos containers.

---

## ‚ö° Como rodar a aplica√ß√£o

1. Clone o reposit√≥rio:

```bash
git clone https://github.com/lipicio/Smart-To-Do-List.git
cd Smart-To-Do-List
```

2. Suba os containers Docker:

```bash
docker compose up -d --build
```

3. Verifique se os containers est√£o rodando:

```bash
docker compose ps
```

4. Teste os endpoints:

```bash
Backend NestJS: http://localhost:3001
Frontend Next.js: http://localhost:3000
```

---

## üõ† Comandos √∫teis

- Ver logss:

```bash
docker logs -f <Nome_do_Container>
```

- Parar containers:

```bash
docker compose down
```

- Reiniciar containers:

```bash
docker compose restart
```

- Entrar em um container:

```bash
docker compose exec backend bash
docker compose exec frontend bash
```

---

## üìù Observa√ß√µes

* A chave da API do Openrouter deve ser enviada pelo usu√°rio a cada solicita√ß√£o (a aplica√ß√£o n√£o ir√° armazenar o token)
* A aplica√ß√£o utiliza Tailwind CSS, React Compiler e App Router no frontend para uma interface reativa e moderna.
* Backend NestJS est√° em modo desenvolvimento, permitindo hot reload.
* No backend utilizei o repository pattern (um dos pilares do DDD) para separar a camada de neg√≥cio e de infra, para isso utilizo inje√ß√£o de dependencias e invers√£o de controle. Essa abordagem √© interessate pois facilita a troca da estrutura de armazenamento de dados (Atualmente utilizando SQLite) e provedor de IA (Atualmente utilizando openrouter) sem compromenter a camada de negocio da aplica√ß√£o. Tamb√©m facilita (muito) a cria√ß√£o de testes unit√°rios que, inclusive, foram contemplados no projeto e adicionados a pipeline do github.

---
